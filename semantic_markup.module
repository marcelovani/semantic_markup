<?php
/**
 * @file
 * General functions and hook implementations.
 *
 * @see https://developers.google.com/structured-data/testing-tool/
 */


use Symfony\Component\CssSelector\CssSelectorConverter;

// Symfony component library auto loader.
spl_autoload_register('semantic_markup_autoload', TRUE, TRUE);

/**
 * Autoloader callback for symfony_css-selector library.
 */
function semantic_markup_autoload($class) {
  if (strpos($class, 'Symfony\Component\CssSelector') === FALSE) {
    // Not a CssSelector component.
    return;
  }
  module_load_include('module', 'libraries');
  $path = libraries_get_path('symfony_css_selector');
  $class_path = str_replace('\\', '/', $class);
  $class_path = str_replace('Symfony/Component/CssSelector', '',  $class_path);
  if (file_exists(($path . '/' . $class_path . '.php'))) {
    include($path . '/' . $class_path . '.php');
  }
}

/**
 * Implements hook_libraries_info().
 */
function semantic_markup_libraries_info() {
  // Use the symfony css selector component.
  return array(
    'symfony_css_selector' => array(
      'title' => 'Symfony CssSelector Component',
      'vendor url' => 'http://symfony.com/doc/current/components/css_selector.html',
      'download url' => 'https://github.com/symfony/css-selector',
      'version callback' => 'semantic_markup_get_css_selector_version',
      'files' => array(
        'js' => array(
          'composer.json',
        ),
      ),
    ),
  );
}

/**
 * Callback for symfony_css-selector 'version callback'.
 */
function semantic_markup_get_css_selector_version($library) {
  // Read the composer file.
  $file = DRUPAL_ROOT . '/' . $library['library path'] . '/' . key($library['files']['js']);
  if (!file_exists($file)) {
    return;
  }
  $json = file_get_contents($file);
  $data = json_decode($json,TRUE);
  if (isset($data['extra']['branch-alias']['dev-master'])) {
    return str_replace('-dev', '', $data['extra']['branch-alias']['dev-master']);
  }
  return;
}

/**
 * Just to show that css to xpath works.
 */
function semantic_markup_demo_css_to_xpath($css_selector = 'div.item > h4 > a') {
  // Try to load the library and check if it worked.
  if (($library = libraries_load('symfony_css_selector')) && !empty($library['loaded'])) {
    $converter = new CssSelectorConverter();
    print $converter->toXPath($css_selector) . "\n";
  }
  else {
    print "Library not found.\n";
  }
}


/**
 * Implements hook_process_html().
 */
function semantic_markup_process_html(&$variables) {
  $rdfa_mappings = module_invoke_all('semantic_markup_mappings');
  if (!empty($rdfa_mappings)) {
    // Create DOM XPath object to process.
    $dom = filter_dom_load($variables['page']);
    $dom_xpath = new DOMXPath($dom);

    foreach ($rdfa_mappings as $rdfa_mapping) {
      switch ($rdfa_mapping['type']) {
        case 'global':
          // Process global mappings.
          _semantic_markup_process_rdf_mappings($dom_xpath, $rdfa_mapping['mappings']);
          break;
        case 'node':
          $node = menu_get_object();
          if (isset($node->type) && $node->type == $rdfa_mapping['bundle']) {
            // Pass node context for token replacement.
            _semantic_markup_process_rdf_mappings($dom_xpath, $rdfa_mapping['mappings'], array('node' => $node));
          }
          break;
      }
    }

    // Replace the page HTML with processed RDFa.
    $variables['page'] = filter_dom_serialize($dom);
  }
}

/**
 * Process RDFa mappings.
 *
 * @param DOMXPath $dom_xpath
 *   DOMXPath to be processed.
 * @param array $mappings
 *   rdfa xpath mappings to be processed.
 * @param array $context
 *   context to be used for token replacement.
 */
function _semantic_markup_process_rdf_mappings($dom_xpath, $mappings, $context = array()) {
  foreach ($mappings as $mapping) {
    if ($elements = $dom_xpath->query($mapping['xpath'])) {
      foreach ($elements as $element) {
        if (!empty($mapping['element'])) {
          // Inject new empty element if element name is specified.
          $rdfa_element = _semantic_markup_inject_element($element, $mapping);
        }
        else {
          // Add attributes to xpath element.
          $rdfa_element = $element;
        }

        foreach ($mapping['attributes'] as $key => $config) {
          $value = '';

          if (!empty($config['value'])) {
            // Use 'value' property if the configuration is an array.
            $value = $config['value'];
          }
          elseif (is_scalar($config)) {
            // If the config is a string, use as value.
            $value = $config;
          }

          // Replace any tokens.
          $value = token_replace($value, $context);

          // Run through callback if set.
          if (!empty($config['callback'])) {
            $value = call_user_func($config['callback'], $value);
          }

          // Add attribute to dom element.
          $rdfa_element->setAttribute($key, token_replace($value, $context));
        }
      }
    }
  }
}

/**
 * Create and inject a new dom element.
 *
 * @param $ref_element
 *   Element to inject before or after.
 * @param $mapping
 *   rdfa xpath mapping.
 * @return $element
 *   Newly created element.
 */
function _semantic_markup_inject_element($ref_element, $mapping) {
  $element = $ref_element->ownerDocument->createElement($mapping['element']);

  // Inject new element before or after xpath element based on position config.
  if (!empty($mapping['position']) && $mapping['position'] == 'after') {
    // Position after.
    if($ref_element->nextSibling) {
      $ref_element->parentNode->insertBefore($element, $ref_element->nextSibling);
    }
    else {
      $ref_element->parentNode->appendChild($element);
    }
  }
  else{
    // Position before.
    $ref_element->parentNode->insertBefore($element, $ref_element);
  }

  return $element;
}
